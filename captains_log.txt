        ITERATOR        TYPE
list    bidirectional
map     bidirectional
vector  random access
queue   none            Single end -> first in, first out
stack   none            Single end -> last in, first out

TO-DO :
---------
        A TESTER >> Si ca se trouve je peux m'epargner la peine de faire appel a getNthElement parce que je pense
que quand j'appelle une fonction membre depuis un element n, this = n et pas la tete de la liste.
-> Oui.
        A REGLER >> super flemme de m'en occuper maintenant, mais y'a un segfault quand je veux remplir une liste
avec un reverse_iterator (depuis que j'ai mis la tail ?), mais aucun souci si j'utilise ce meme iterateur
pour de l'affichage...
-> Done.
        Insert avec reverse_iterator ??

QUESTIONS :
--------------
Pourquoi ils ont mis "explicit" devant les constructeurs ?
Pourquoi on utilise un allocator ? Est ce que c'est juste parce que c'est comme ca dans la STL, ou y'a
        une meilleure raison ?
Est ce qu'on a le droit de rajouter des fonctions pas dans la STL dans nos containers ?

[1/03]
Comme d'habitude je piétine, j'ai rassemble dLL et element parce que je me servais pas de l'intermediaire
de toute facon. Du coup, il faut que je fasse en sorte que myList soit un truc constant avec next = first
& prev = last, comme ca j'ai acces aux 2 bouts. Par contre va falloir bien compter.
NEXT TIME : installer le systeme de tete
[26/02]
J'ai divisé DLL et elements de la liste dans l'architecture. Tout fonctionne bien et c'est air-tight, au 
moins jusqu'a SWAP. SPLICE compile pas encore, faut revoir les fonctions a petite echelle. J'ai aussi
changé le type dans l'iterateur (dLL -> element), mais a part ca je l'ai pas touché.
NEXT TIME : splice et les autres modifiers.
[25/02]
Bon j'ai codé splice, mais ca marche pas, et il me parait necessaire a ce stade de separer la DLL : il
faut que j'ai une classe pour le node comme Thomas, et une classe liste. Et faire les fonctions les plus
petites et precises possibles. La je mets beaucoup trop de securités, c'est moche.
NEXT TIME : revoir ENCORE l'architecture de la DLL
[24/02]
J'arrete pas de remettre et renlever le systeme de tail, je sais toujours pas si c'est tres bien, mais
actuellement il y est. J'ai enfin reussi a run tous les tests (sauf modifiers) jusqu'au bout sans segfault,
mais ca leake pas mal, surtout sur le swap donc a investiguer. Swap avec liste vide --> resultats chelou, 
il ajoute des elements, soit d'une autre liste, soit qu'il a gardé en memoire, jcomprends pas...
NEXT TIME : swap / leaks / modifiers 
[22/02]
Je galere un peu sur les fonctions d'insert, entre les segfaults et les double-free. J'ai rajouté aussi
un wagon de queue a ma liste histoire d'encore plus mimic le vrai list.
>> tout compte fait je pense que c'est pas une bonne idee, ca complique beaucoup le code alors que je pense
que j'ai depuis resolu le pb qui a fait que j'ai voulu implementer ca en premier lieu...
>> je fais un push pour enlever tout ca (T-T)
NEXT TIME : segfault insert by range of iterators a resoudre
            rediger erase et les fonctions d'operations
[18/02]
Leaks fixed. En revanche, c'est vraiment trop tendu de faire en sorte que le premier element de la liste
ait du contenu, il vaut mieux qu'il serve juste de wagon de tete, ce sera plus pratique pour les
allocations et les iterateurs. Aussi je suis en train d'essayer de faire un operator<<, mais ca marche
pas de ouf alors ptet que je laisserai tomber, who knows ?
NEXT TIME : reorganiser la liste pour qu'il y ait un ou 2 maillons vides qui servent de bornes.
[16/02-17/02]
J'ai pas mal remanié ma DLL, ma LIST et mes iterateurs, c'est mieux maintenant. Du coup j'ai give up le
systeme de la STL pour les iterateurs, puisqu'en fait ils doivent avoir des comportements specifiques
selon le container donc de toute facon je peux pas autant les reutiliser aue ce aue je pensais. Du coup,
j'en ai créé un bidirectionnel general, et j'en fais heriter un const, un reverse et un const reverse.
Maintenant les fonctions de bases marchent sans segfault et elles font bien ce que je veux, par contre
ca leake a mort !!
NEXT TIME : faire la chasse aux leaks
            ecrire les tests des les fonctions de LIST pas encore testées
            continuer de rediger les fonctions de modification de LIST
            -> tester ce que je peux enlever comme securités redondantes dans dLL
[11/02]
A priori je faisais pas trop de la merde avec ma dLL et mon allocator, du coup j'ai ecrit les fonctions
dont j'aurais besoin pour la manipuler, et j'ai bien attaqué les fonctions de LIST. Du coup j'ai voulu
tester ce que j'avais écrit mais apres 1h a regler les pbs de compilation, j'ai pris un segfault de
l'espace, du coup je debuggerai demain.
NEXT TIME : eliminer les segfaults
[5/02]
Bon ben j'ai essayé de coder les fonctions de QUEUE et STACK, mais j'ai découvert que dedans y'avait un 
underlying container qui devra etre... une LIST ! Donc j'ai essayé de coder les fonctions de LIST, mais
j'ai vu qu'il fallait utiliser std::allocator pour creer mes elements et la j'ai vu trouble.
J'ai créé une doublyLinkedList, mais je comprends pas trop bien comment allouer mes elements.
NEXT TIME : comprendre comment utiliser std::allocator (-> relire ce que Thomas m'a ecrit a ce sujet)
[4/02]
J'ai presque fini les iterateurs, ils heritent tous de ForwardIterator -> bidirectional -> random_access
Sur LIST, j'ai fait tous les typedefs et recopié toutes les fcts membres et non membres de cppreference 
NEXT TIME : iterateurs -> manque plus que random_access (operator[] et autres features)
            architecture -> recopier les membres de STACK, QUEUE, MAP & VECTOR
            containers -> commencer par STACK ou QUEUE plutot que LIST qui a l'air assez badass qd mm
[3/02]
Je viens de comprendre qu'il faudrait réimplémenter every fucking iterator, j'ai envie de mourrir.
NEXT TIME : faire un input iterator deja, puis rajouter les features et surcharges dans les heritages
[2/02]
Juste créé une architecture globale qui compile avec tous les containers dans le namespace ft 
NEXT TIME : commencer a écrire les fonctions de LIST