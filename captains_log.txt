        ITERATOR        TYPE
list    bidirectional
map     bidirectional
vector  random access
queue   none            Single end -> first in, first out
stack   none            Single end -> last in, first out

Ouais en gros tout ce qui est allocutions des types qui sont passer en template
au lieu de faire new value_type
Tu va faire un Alloc allocator; allocator.allocate(n); allocator.construct(value);
Tu va passer par l'allocator
Apres quand tu va faire une liste chainer si tu veux creer un maillon a ta liste tu peut utiliser new
Du moment que le value_type soit allouer construit detruit et desallouer par le allocator
T'as pas a le refaire parce que c'est un truc qu'on te passera en template
Mais ils serront tous contruit a partir de cette base std::allocator
A TESTER >> Si ca se trouve je peux m'epargner la peine de faire appel a getNthElement parce que je pense
que quand j'appelle une fonction membre depuis un element n, this = n et pas la tete de la liste.
-> Oui.

QUESTIONS :
Pourquoi ils ont mis "explicit" devant les constructeurs ?
Pourquoi on utilise un allocator ? Est ce que c'est juste parce que c'est comme ca dans la STL, ou y'a
        une meilleure raison ?

[18/02]
Leaks fixed. En revanche, c'est vraiment trop tendu de faire en sorte que le premier element de la liste
ait du contenu, il vaut mieux qu'il serve juste de wagon de tete, ce sera plus pratique pour les
allocations et les iterateurs.
NEXT TIME : reorganiser la liste pour qu'il y ait un ou 2 maillons vides qui servent de bornes.
[16/02-17/02]
J'ai pas mal remanié ma DLL, ma LIST et mes iterateurs, c'est mieux maintenant. Du coup j'ai give up le
systeme de la STL pour les iterateurs, puisqu'en fait ils doivent avoir des comportements specifiques
selon le container donc de toute facon je peux pas autant les reutiliser aue ce aue je pensais. Du coup,
j'en ai créé un bidirectionnel general, et j'en fais heriter un const, un reverse et un const reverse.
Maintenant les fonctions de bases marchent sans segfault et elles font bien ce que je veux, par contre
ca leake a mort !!
NEXT TIME : faire la chasse aux leaks
            ecrire les tests des les fonctions de LIST pas encore testées
            continuer de rediger les fonctions de modification de LIST
            -> tester ce que je peux enlever comme securités redondantes dans dLL
[11/02]
A priori je faisais pas trop de la merde avec ma dLL et mon allocator, du coup j'ai ecrit les fonctions
dont j'aurais besoin pour la manipuler, et j'ai bien attaqué les fonctions de LIST. Du coup j'ai voulu
tester ce que j'avais écrit mais apres 1h a regler les pbs de compilation, j'ai pris un segfault de
l'espace, du coup je debuggerai demain.
NEXT TIME : eliminer les segfaults
[5/02]
Bon ben j'ai essayé de coder les fonctions de QUEUE et STACK, mais j'ai découvert que dedans y'avait un 
underlying container qui devra etre... une LIST ! Donc j'ai essayé de coder les fonctions de LIST, mais
j'ai vu qu'il fallait utiliser std::allocator pour creer mes elements et la j'ai vu trouble.
J'ai créé une doublyLinkedList, mais je comprends pas trop bien comment allouer mes elements.
NEXT TIME : comprendre comment utiliser std::allocator (-> relire ce que Thomas m'a ecrit a ce sujet)
[4/02]
J'ai presque fini les iterateurs, ils heritent tous de ForwardIterator -> bidirectional -> random_access
Sur LIST, j'ai fait tous les typedefs et recopié toutes les fcts membres et non membres de cppreference 
NEXT TIME : iterateurs -> manque plus que random_access (operator[] et autres features)
            architecture -> recopier les membres de STACK, QUEUE, MAP & VECTOR
            containers -> commencer par STACK ou QUEUE plutot que LIST qui a l'air assez badass qd mm
[3/02]
Je viens de comprendre qu'il faudrait réimplémenter every fucking iterator, j'ai envie de mourrir.
NEXT TIME : faire un input iterator deja, puis rajouter les features et surcharges dans les heritages
[2/02]
Juste créé une architecture globale qui compile avec tous les containers dans le namespace ft 
NEXT TIME : commencer a écrire les fonctions de LIST